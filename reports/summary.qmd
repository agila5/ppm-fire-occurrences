---
title: "Non-separable spatio-temporal Poisson point process models for fire occurrences - Companion code"
author: "Nicoletta D'Angelo, Alessandro Albano, Andrea Gilardi, Giada Adelfio"
format: 
  html: 
    page-layout: full
    knitr: 
      opts_chunk: 
        collapse: true
        crop: true
        dpi: 50
        echo: true
    toc: true
    embed-resources: false
date: today
---

```{r setup-and-packages}
#| include: false
knitr::knit_hooks$set(crop = knitr::hook_pdfcrop)
options(width = 100, rgl.useNULL = TRUE)
```

This document replicates the analyses included in the paper entitled *Non-separable spatio-temporal Poisson point process models for fire occurrences*. 

## Premilinary steps

Load relevant packages

```{r}
library(here)
source(here("R", "packages.R"))
```

Download (if necessary) relevant data from the Github Repository

```{r}
if (!dir.exists(here("data"))) {
  dir.create(here("data"))
}
pb_download(
  file = c(
    "DL_FIRE_J1V-C2_510187.zip", "confini-regioni.zip", "land-use.zip", "NDVI.zip", 
    "environmental-variables.zip", "INGV-elev.zip"
  ), 
  dest = here("data"), 
  repo = "agila5/ppm-fire-occurrences",
  tag = "v1-data", 
  overwrite = TRUE, 
  show_progress = FALSE
)
```

Define a folder where we will cache long running tasks

```{r}
if (!dir.exists(here("qcache"))) {
  dir.create(here("qcache"))
}
```

Define several bounding boxes that will be used to create some plots. 

```{r}
define_bb <- function(
    xmin,
    ymin,
    xmax,
    ymax,
    crs) {
  bbox <- st_bbox(
    c(xmin = xmin, ymin = ymin, xmax = xmax, ymax = ymax),
    crs = crs
  ) |> st_as_sfc()

  if (st_crs(bbox) == st_crs(3003)) {
    return(bbox)
  }
  st_transform(bbox, 3003)
}

pantelleria_bbox <- define_bb(
  xmin = 11.92586, ymin = 36.73438,
  xmax = 12.05684, ymax = 36.83939,
  crs = "OGC:CRS84"
)
linosa_bbox <- define_bb(
  xmin = 12.84838, ymin = 35.85436,
  xmax = 12.88393, ymax = 35.87595,
  crs = "OGC:CRS84"
)
lampedusa_bbox <- define_bb(
  xmin = 12.51730, ymin = 35.49295,
  xmax = 12.63422, ymax = 35.52931,
  crs = "OGC:CRS84"
)
palermo_bbox <- define_bb(
  xmin = 1871427, xmax = 1890744,
  ymin = 4219859, ymax = 4240118,
  crs = 3003
)
sicily_mainland_bbox <- define_bb(
  xmin = 1807082, ymin = 4041434,
  xmax = 2083886, ymax = 4265502,
  crs = 3003
)
```

Define also several vectors that will be used to place inset maps into figures.

```{r}
#| code-fold: false
xrange_pantelleria <- st_bbox(pantelleria_bbox)[c(1, 3)]
xrange_lampedusa <- st_bbox(lampedusa_bbox)[c(1, 3)]
xrange_linosa <- st_bbox(linosa_bbox)[c(1, 3)]

yrange_pantelleria <- st_bbox(pantelleria_bbox)[c(2, 4)]
yrange_lampedusa <- st_bbox(lampedusa_bbox)[c(2, 4)]
yrange_linosa <- st_bbox(linosa_bbox)[c(2, 4)]
```

## Section 2

### Figure 1

Load relevant data regarding the fires in Italy

```{r}
fires_italy <- st_read(
  paste0("/vsizip/", here("data", "DL_FIRE_J1V-C2_510187.zip")), 
  quiet = TRUE
) |> 
  st_transform(3003) |> 
  mutate(
    ACQ_DATETIME = ymd_hm(paste0(ACQ_DATE, " ", ACQ_TIME))
  )
```

and borders of the regions

```{r}
confini_regioni <- st_read(
  paste0("/vsizip/", here("data", "confini-regioni.zip"), "/confini-regioni"), 
  quiet = TRUE
) |> 
  st_transform(3003)
```

Compute the number of fires in each region

```{r}
confini_regioni[["counts"]] <- st_intersects(confini_regioni, fires_italy) |> lengths()
```

and plot it

```{r}
#| fig-width: 7.5
#| fig-height: 9
#| out-width: 70%
#| fig-align: center
if (!interactive()) {
  ggplot(data = confini_regioni) + 
  geom_sf(aes(fill = counts)) + 
  scale_fill_continuous_c4a_seq("brewer.oranges")+
  theme_minimal() + 
  theme(
    legend.title = element_text(size = 14), 
    legend.text = element_text(size = 10), 
    legend.key.height = unit(2, "lines")
  ) + 
  labs(fill = "Fire counts")
}
```

```{r}
#| include: false
rm(confini_regioni)
```

### Figure 2

Now we need to filter the fires that occurred in Sicily using the bounding box defined by the land-use data object. Therefore, we need to load it 

```{r}
land_use_raw <- st_read(
  paste0("/vsizip/", here("data", "land-use.zip"), "/land-use"), 
  quiet = TRUE
)
```

and apply a series of preprocessing steps to simplify and tidy its structure (following the procedures described in the paper)

```{r}
#| message: false
land_use_tidy <- qcache(
  {
    land_use_raw |>
      select(Code_18) |>
      st_transform(crs = 3003) |> # for spatstat
      st_set_agr(c(Code_18 = "constant")) |> # remove warning on "st_cast"
      st_cast("POLYGON") |>
      st_make_valid() |>
      # Merge together areas with the same macro code
      mutate(Code_18 = substr(Code_18, 1, 1)) |> # Get the macro code
      mutate(
        Code_18 = factor(
          Code_18,
          labels = c(
            "Artificial surfaces",
            "Agricultural areas",
            "Forests",
            "Water bodies",
            "Water bodies"
          )
        )
      ) |>
      group_by(Code_18) |>
      summarise()
  },
  name = "land_use_tidy",
  cache_dir = here("qcache") 
)
```

```{r}
#| include: false
rm(land_use_raw)
```

We need to convert it into `tess` format for `spatstat`

```{r}
owins <-
  lapply(
    st_geometry(land_use_tidy),
    as.owin
  ) |>
  set_names(
    land_use_tidy[["Code_18"]]
  )
land_use_tess <- tess(tiles = owins); rm(owins)
```

and use its `Window` attribute to filter the fire points

```{r}
fires_sicily <- fires_italy[
  Window(land_use_tess) |> st_as_sfc() |> st_set_crs(3003), 
]
```

There are `{r} nrow(fires_sicily)` events that occurred during 2023 in the region. We can check their monthly temporal distribution and compare with the whole country (Figure 2) as follows:

```{r}
#| fig-height: 5
#| fig-width: 7
#| out-width: 70%
#| fig-align: center
if (!interactive()) {
  bind_rows(
  Italy = fires_italy |> st_drop_geometry(), 
  Sicily = fires_sicily |> st_drop_geometry(), 
  .id = "ID"
) |> 
  group_by(ID, month = month(ACQ_DATETIME, label = TRUE)) |> 
  count() |> 
  ggplot(aes(x = month, y = n, fill = ID)) + 
  geom_col(position = position_dodge(), alpha = 0.75) + 
  geom_text(aes(label = n), fontface = "bold", vjust = 1.5, position = position_dodge(.9), size = 2) + 
  scale_fill_manual(values = c("orange", "brown")) + 
  labs(x = "\n Month", y = "Fire Counts\n", fill = "") + 
  theme_minimal() + 
  theme(
    axis.title = element_text(face = "bold", size = 12)
  )
}
```

```{r}
#| include: false
rm(fires_italy)
```

### Figure 3

The following map shows spatial distribution of such events (Figure 3): 

```{r}
land_use_tidy <- land_use_tidy |> 
  st_set_agr(c(Code_18 = "constant")) |> # remove warning on "st_cast"
  st_cast("POLYGON")
land_use_tidy_union <- qcache(
  {
    land_use_tidy |> 
      st_geometry() |> 
      st_union() |> 
      st_cast("POLYGON")
  }, 
  name = "land_use_tidy_union", 
  cache_dir = here("qcache")
)

idx_eventi_pantelleria <- st_contains(pantelleria_bbox, fires_sicily) |> unlist()
idx_eventi_linosa <- st_contains(linosa_bbox, fires_sicily) |> unlist()
idx_eventi_lampedusa <- st_contains(lampedusa_bbox, fires_sicily) |> unlist()
  
idx_shape_pantelleria <- st_intersects(pantelleria_bbox, land_use_tidy_union) |> unlist()
shape_pantelleria <- land_use_tidy_union[idx_shape_pantelleria]

idx_shape_linosa <- st_intersects(linosa_bbox, land_use_tidy_union) |> unlist()
shape_linosa <- land_use_tidy_union[idx_shape_linosa]

idx_shape_lampedusa <- st_intersects(lampedusa_bbox, land_use_tidy_union) |> unlist()
shape_lampedusa <- land_use_tidy_union[idx_shape_lampedusa]

shape_everything_else <- land_use_tidy_union[
  -c(idx_shape_lampedusa, idx_shape_linosa, idx_shape_pantelleria)
]
```

```{r}
#| fig-width: 12
#| fig-height: 10
#| out-width: 70%
#| fig-align: center
if (!interactive()) {
  # Main plot
  main_plot <- ggplot() +
    geom_sf(
      data = land_use_tidy_union[-c(
        idx_shape_lampedusa, idx_shape_linosa, idx_shape_pantelleria
      )]
    ) +
    geom_sf(
      data = fires_sicily[-c(
        idx_eventi_pantelleria, idx_eventi_linosa, idx_eventi_lampedusa
      ), ]
    ) +
    theme_light() +
    theme(panel.background = element_rect(fill = "white"), axis.text = element_text(size = 13.5))

  inset_region <- ggplot() +
    geom_sf(data = land_use_tidy_union) +
    geom_sf(data = lampedusa_bbox |> st_boundary()) +
    geom_sf(data = linosa_bbox |> st_boundary()) +
    geom_sf(data = pantelleria_bbox |> st_boundary()) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", linewidth = 3),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  inset_pantelleria <- ggplot() +
    geom_sf(data = land_use_tidy_union[idx_shape_pantelleria]) +
    geom_sf(data = fires_sicily[idx_eventi_pantelleria, ]) +
    coord_sf(xlim = c(1760070, 1773730), ylim = c(4068772, 4082023)) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", linewidth = 3),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  inset_linosa <- ggplot() +
    geom_sf(data = land_use_tidy_union[idx_shape_linosa]) +
    geom_sf(data = fires_sicily[idx_eventi_linosa, ]) +
    coord_sf(xlim = c(1846520, 1851748), ylim = c(3973711, 3978066)) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", linewidth = 3),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  inset_lampedusa <- ggplot() +
    geom_sf(data = land_use_tidy_union[idx_shape_lampedusa]) +
    geom_sf(data = fires_sicily[idx_eventi_lampedusa, ]) +
    coord_sf(xlim = c(1818045, 1830515), ylim = c(3932694, 3938490)) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", linewidth = 3),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  ggplot() +
    coord_equal(xlim = c(0, 24), ylim = c(0, 19), expand = FALSE) +
    annotation_custom(
      ggplotGrob(main_plot),
      xmin = 0, xmax = 24, ymin = 0, ymax = 19
    ) +
    annotation_custom(
      ggplotGrob(inset_region),
      xmin = 1.5, xmax = 7, ymin = 12.5, ymax = 18
    ) +
    annotation_custom(
      ggplotGrob(inset_pantelleria),
      xmin = 2, xmax = 5, ymin = 2, ymax = 5
    ) +
    annotation_custom(
      ggplotGrob(inset_lampedusa),
      xmin = 5.75,
      xmax = 5.75 + 3 * diff(xrange_lampedusa) / diff(xrange_pantelleria),
      ymin = 2.6,
      ymax = 2.6 + 5 * diff(yrange_lampedusa) / diff(yrange_pantelleria)
    ) +
    annotation_custom(
      ggplotGrob(inset_linosa),
      xmin = 9.1,
      xmax = 9.1 + 3 * diff(xrange_linosa) / diff(xrange_pantelleria),
      ymin = 3,
      ymax = 3 + 5 * diff(yrange_linosa) / diff(yrange_pantelleria)
    ) +
    annotate(
      "segment",
      x = 3.5, y = 5.1,
      xend = 2.825, yend = 10.2,
      lineend = "round",
      linewidth = 1
    ) +
    annotate(
      "segment",
      x = 2.7, y = 11,
      xend = 2.25, yend = 14.3,
      arrow = arrow(),
      lineend = "round",
      linewidth = 1
    ) +
    annotate(
      "segment",
      x = 7.1, y = 4.3,
      xend = 4.355, yend = 10,
      lineend = "round",
      linewidth = 1
    ) +
    annotate(
      "segment",
      x = 4.05, y = 10.7,
      xend = 3.1, yend = 12.65,
      arrow = arrow(),
      lineend = "round",
      linewidth = 1,
    ) +
    annotate(
      "segment",
      x = 9.5, y = 4,
      xend = 7, yend = 7.75,
      lineend = "round",
      linewidth = 1,
    ) +
    annotate(
      "segment",
      x = 4.85, y = 11,
      xend = 3.4, yend = 13.2,
      arrow = arrow(),
      lineend = "round",
      linewidth = 1,
    ) +
    labs(x = "", y = "") +
    theme(
      panel.background = element_rect(fill = "white"),
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )
}
```

```{r}
#| include: false
rm(idx_eventi_lampedusa, idx_eventi_linosa, idx_eventi_pantelleria, idx_shape_lampedusa, idx_shape_linosa, idx_shape_pantelleria)
if (!interactive()) {
  rm(inset_lampedusa, inset_linosa, inset_pantelleria, inset_region, main_plot)
}
```

### Figure 4

Spatio-temporal monthly distribution of the events occurred in the mainland. First we need to define such mainland

```{r}
idx_mainland <- which.max(st_area(land_use_tidy_union))
mainland <- land_use_tidy_union[idx_mainland]; rm(idx_mainland)
```

and then we can plot such events

```{r}
#| fig-width: 10
#| fig-height: 8
#| out-width: 70%
#| fig-align: center
if (!interactive()) {
  fires_sicily |> 
    st_filter(mainland) |> 
    mutate(month = month(ACQ_DATETIME, label = TRUE, abbr = FALSE)) |> 
    ggplot() + 
    geom_sf(data = mainland) +
    geom_sf() + 
    facet_wrap(~month) + 
    theme_light() + 
    scale_x_continuous(breaks = c(12.5, 13.5, 14.5, 15.5)) +
    theme(
      strip.text = element_text(face = "bold", colour = "black")
    )
}
```

### Figure 5

We need to define a series of indices that will be used in the inset maps

```{r}
idx_pantelleria <- st_intersects(pantelleria_bbox, land_use_tidy) |> unlist()
idx_linosa <- st_intersects(linosa_bbox, land_use_tidy) |> unlist()
idx_lampedusa <- st_intersects(lampedusa_bbox, land_use_tidy) |> unlist()
land_use_palermo <- st_intersection(land_use_tidy, palermo_bbox)
```

and then we can visualise the land use variable

```{r}
#| fig-width: 12
#| fig-height: 10
#| fig-align: center
#| out-width: 70%
if (!interactive()) {
  mainland_plot <- ggplot() +
    geom_sf(
      data = land_use_tidy[-c(
        idx_lampedusa, idx_linosa, idx_pantelleria
      ), ],
      aes(fill = Code_18)
    ) +
    geom_sf(
      data = st_boundary(palermo_bbox),
      linewidth = 1
    ) +
    theme_light() +
    scale_fill_manual(
      values = c(
        "Artificial surfaces" = "#a50000",
        "Agricultural areas" = "#e49703",
        "Forests" = "#287201",
        "Water bodies" = "#bdeafe"
      )
    ) +
    theme(
      axis.text = element_text(size = 13.5),
      legend.text = element_text(size = 15),
      plot.title = element_text(face = "bold", size = 18, hjust = 0.5)
    ) +
    labs(fill = "", title = "Land usage")

  palermo_zoom <- ggplot() +
    geom_sf(
      data = land_use_palermo,
      aes(fill = Code_18),
      show.legend = FALSE
    ) +
    geom_sf(
      data = st_boundary(palermo_bbox),
      linewidth = 1.5
    ) +
    theme_light() +
    coord_sf(datum = st_crs(3003)) +
    scale_fill_manual(
      values = c(
        "Artificial surfaces" = "#a50000",
        "Agricultural areas" = "#e49703",
        "Forests" = "#287201",
        "Water bodies" = "#bdeafe"
      )
    ) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", colour = NA),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  pantelleria_zoom <- ggplot() +
    geom_sf(
      data = land_use_tidy[idx_pantelleria, ] |> st_transform(4326),
      aes(fill = Code_18),
      show.legend = FALSE
    ) +
    geom_sf(
      data = st_boundary(land_use_tidy_union[pantelleria_bbox, ]),
      linewidth = 1
    ) +
    theme_light() +
    scale_fill_manual(
      values = c(
        "Artificial surfaces" = "#a50000",
        "Agricultural areas" = "#e49703",
        "Forests" = "#287201",
        "Water bodies" = "#bdeafe"
      )
    ) +
    theme(
      panel.border = element_rect(fill = NA, linewidth = 2, colour = "black"),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      panel.grid = element_blank()
    )

  lampedusa_zoom <- ggplot() +
    geom_sf(
      data = land_use_tidy[idx_lampedusa, ] |> st_transform(4326),
      aes(fill = Code_18),
      show.legend = FALSE
    ) +
    geom_sf(
      data = st_boundary(land_use_tidy_union[lampedusa_bbox, ]),
      linewidth = 1
    ) +
    theme_light() +
    scale_fill_manual(
      values = c(
        "Artificial surfaces" = "#a50000",
        "Agricultural areas" = "#e49703",
        "Forests" = "#287201",
        "Water bodies" = "#bdeafe"
      )
    ) +
    theme(
      panel.border = element_rect(fill = NA, linewidth = 2, colour = "black"),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      panel.grid = element_blank()
    )

  linosa_zoom <- ggplot() +
    geom_sf(
      data = land_use_tidy[idx_linosa, ] |> st_transform(4326),
      aes(fill = Code_18),
      show.legend = FALSE
    ) +
    geom_sf(
      data = st_boundary(land_use_tidy_union[linosa_bbox, ]),
      linewidth = 1
    ) +
    theme_light() +
    scale_fill_manual(
      values = c(
        "Artificial surfaces" = "#a50000",
        "Agricultural areas" = "#e49703",
        "Forests" = "#287201",
        "Water bodies" = "#bdeafe"
      )
    ) +
    theme(
      panel.border = element_rect(fill = NA, linewidth = 1, colour = "black"),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      panel.grid = element_blank()
    )

  ggplot() +
    coord_equal(xlim = c(0, 24), ylim = c(0, 20), expand = FALSE) +
    annotation_custom(
      ggplotGrob(mainland_plot),
      xmin = 0, xmax = 24, ymin = 0, ymax = 20
    ) +
    annotation_custom(
      ggplotGrob(palermo_zoom),
      xmin = 1.8, xmax = 6, ymin = 12.15, ymax = 16.65
    ) +
    annotation_custom(
      ggplotGrob(pantelleria_zoom),
      xmin = 2, xmax = 5, ymin = 4, ymax = 7
    ) +
    annotation_custom(
      ggplotGrob(lampedusa_zoom),
      xmin = 5.25, xmax = 5.25 + 3 * diff(xrange_lampedusa) / diff(xrange_pantelleria),
      ymin = 4.6, ymax = 4.6 + 5 * diff(yrange_lampedusa) / diff(yrange_pantelleria)
    ) +
    annotation_custom(
      ggplotGrob(linosa_zoom),
      xmin = 8.15, xmax = 8.15 + 3 * diff(xrange_linosa) / diff(xrange_pantelleria),
      ymin = 5, ymax = 5 + 5 * diff(yrange_linosa) / diff(yrange_pantelleria)
    ) +
    annotate(
      "segment",
      x = 6, y = 14.75,
      xend = 8, yend = 12.75,
      arrow = arrow(),
      lineend = "round",
      linewidth = 1,
    ) +
    theme(
      panel.background = element_rect(fill = "white"),
      axis.text = element_blank(),
      axis.ticks = element_blank()
    ) +
    labs(x = "", y = "")
}
```

```{r}
#| include: false
rm(land_use_palermo, idx_lampedusa, idx_linosa, idx_pantelleria)
if (!interactive()) {
  rm(lampedusa_zoom, linosa_zoom, mainland_plot, palermo_zoom, pantelleria_zoom)
}
```

### Figure 6

Graphical representation of the moving grid for Horn's Algorithm

```{r}
#| fig-width: 10
#| fig-height: 8
#| out-width: 70%
#| fig-align: center
if (!interactive()) {
  horn_grid <- st_make_grid(
    cellsize = c(1, 1), offset = c(0, 0), n = c(3, 3)
  )
  ggplot() + 
    geom_sf(
      data = horn_grid[5], 
      fill = grey(0.85)
    ) + 
    geom_sf(data = st_boundary(horn_grid), linewidth = 1) + 
    geom_sf_text(
    data = st_centroid(horn_grid),
    label = c( # NB: The grid is specified in reverse order
      "Alt[3]", "Alt[4]", "Alt[5]", 
      "Alt[2]", "", "Alt[6]",
      "Alt[1]", "Alt[8]", "Alt[7]"
    ), 
    parse = TRUE, 
    size = 13, 
    fontface = "bold"
  ) + 
  labs(x = "Longitude", y = "Latitude") + 
  theme(
    panel.background = element_blank(), 
    axis.text = element_blank(), 
    axis.ticks = element_blank(), 
    axis.title = element_text(size = 40, face = "bold")
  )
}
```

```{r}
#| include: false
if (!interactive()) {
  rm(horn_grid)
}
```

### Figure 7a

Now we need to focus on the Elevation in Sicily. First, we define an auxiliary function

```{r}
generate_orig_tif <- function(paths, tmp_dir) {
  unzip(paths, exdir = tmp_dir)
  tif_paths <- list.files(
    tmp_dir, pattern = "\\.tif", recursive = TRUE, 
    full.names = TRUE
  )
  tifs <- lapply(tif_paths, read_stars)
  out <- do.call(st_mosaic, tifs); invisible(gc())
  out
}
```

and then read-in the data

```{r}
elev <- qcache(
  {
    tmp_dir <- tempdir()
    orig_tif <- generate_orig_tif(here("data", "INGV-elev.zip"), tmp_dir)
    # Clean files
    unlink(paste0(tmp_dir, "INGV-elev"), recursive = TRUE)
    invisible(gc())
    tif <- orig_tif |>
      st_downsample(n = c(10, 10)) |>
      st_warp(crs = 3003)
    # Clean files
    unlink(list.files(tmp_dir, pattern = "\\.tif", full.names = TRUE))
    rm(orig_tif)
    invisible(gc())

    tif <- tif[st_bbox(land_use_tidy_union)]
    tif[land_use_tidy_union]
  },
  name = "elev",
  cache_dir = here("qcache")
)
invisible(gc())
```

```{r}
#| include: false
if (exists("tif")) {
  rm(tif)
}
```

Now we can represent it

```{r}
elev_mainland <- (elev |> st_downsample(c(5, 5)))[shape_everything_else]
elev_pantelleria <- elev[shape_pantelleria]
elev_lampedusa <- elev[shape_lampedusa]
elev_linosa <- elev[shape_linosa]
```

```{r}
#| fig-width: 12
#| fig-height: 10
#| out-width: 70%
#| fig-align: center
if (!interactive()) {
  elev_mainplot <- ggplot() +
    geom_sf(
      aes(fill = e41005_s10.tif),
      data = elev_mainland |> st_as_sf(),
      linewidth = NA
    ) +
    theme_light() +
    scale_fill_gradientn(
      breaks = c(0, 500, 1000, 2000, 3000),
      colours = terrain.colors(100),
      trans = modulus_trans(p = 0.8)
    ) +
    theme(
      axis.text = element_text(size = 19.5),
      legend.text = element_text(size = 19.5),
      legend.key.height = unit(3, "lines"),
      plot.title = element_text(face = "bold", size = 26, hjust = 0.5)
    ) +
    labs(fill = "", title = "Altitude (m)")

  elev_pantelleria_plot <- ggplot() +
    geom_stars(data = elev_pantelleria |> st_warp(crs = 4326), na.action = na.omit, show.legend = FALSE) +
    coord_sf(crs = 4326) +
    scale_fill_gradientn(colours = terrain.colors(100), trans = modulus_trans(p = 0.8), limits = c(0, 3000)) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", linewidth = 3),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  elev_lampedusa_plot <- ggplot() +
    geom_stars(
      data = elev_lampedusa |>
        st_warp(crs = 4326),
      na.action = na.omit,
      show.legend = FALSE
    ) +
    coord_sf(crs = 4326) +
    scale_fill_gradientn(colours = terrain.colors(100), trans = modulus_trans(p = 0.7), limits = c(0, 3000)) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", linewidth = 3),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  elev_linosa_plot <- ggplot() +
    geom_stars(
      data = elev_linosa |>
        st_warp(crs = 4326),
      na.action = na.omit,
      show.legend = FALSE
    ) +
    coord_sf(crs = 4326) +
    scale_fill_gradientn(colours = terrain.colors(100), trans = modulus_trans(p = 0.7), limits = c(0, 3000)) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", linewidth = 2),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  ggplot() +
    coord_equal(xlim = c(0, 24), ylim = c(0, 20), expand = FALSE) +
    annotation_custom(
      ggplotGrob(elev_mainplot),
      xmin = 0, xmax = 24, ymin = 0, ymax = 20
    ) +
    annotation_custom(
      ggplotGrob(elev_pantelleria_plot),
      xmin = 2.5, xmax = 5.5, ymin = 3.15, ymax = 6.15
    ) +
    annotation_custom(
      ggplotGrob(elev_lampedusa_plot),
      xmin = 6.25, xmax = 6.25 + 3 * diff(xrange_lampedusa) / diff(xrange_pantelleria),
      ymin = 3.8, ymax = 3.8 + 3 * diff(yrange_lampedusa) / diff(yrange_pantelleria)
    ) +
    annotation_custom(
      ggplotGrob(elev_linosa_plot),
      xmin = 9.5, xmax = 9.5 + 3 * diff(xrange_linosa) / diff(xrange_pantelleria),
      ymin = 4.2, ymax = 4.2 + 3 * diff(yrange_linosa) / diff(yrange_pantelleria)
    ) +
    theme(panel.background = element_rect(fill = "white"))
}
```

```{r}
#| include: false
rm(elev_lampedusa, elev_linosa, elev_mainland, elev_pantelleria)
if (!interactive()) {
  rm(elev_mainplot, elev_pantelleria_plot, elev_lampedusa_plot, elev_linosa_plot)
}
```

### Figure 7b

As we mentioned in the paper, the slope is computed using the GDAL DEM tools

```{r}
slope <- qcache(
  {
    tmp_dir <- tempdir()
    orig_tif <- generate_orig_tif(here("data", "INGV-elev.zip"), tmp_dir)
    unlink(paste0(tmp_dir, "INGV-elev"), recursive = TRUE)
    invisible(gc())
    
    temp_tif <- tempfile(fileext = ".tif")
    write_stars(orig_tif, temp_tif, progress = FALSE)
    
    temp_slope <- tempfile(fileext = ".tif")
    gdaldem("slope", temp_tif, temp_slope)
    slope <- read_stars(temp_slope)
    slope <- slope |> st_downsample(c(10, 10)) |> st_warp(crs = 3003)
    slope <- slope[st_bbox(land_use_tidy_union)]
    slope <- slope[land_use_tidy_union]
    
    unlink(list.files(tmp_dir, pattern = "\\.tif", full.names = TRUE))
    rm(orig_tif, temp_tif, temp_slope)
    invisible(gc())
    slope
  },
  name = "slope",
  cache_dir = here("qcache")
)
```

As before, we can subset the `stars` object

```{r}
slope_mainland <- (slope |> st_downsample(c(5, 5)))[shape_everything_else]
slope_pantelleria <- slope[shape_pantelleria]
slope_lampedusa <- slope[shape_lampedusa]
slope_linosa <- slope[shape_linosa]
```

and now we can plot it

```{r}
#| fig-width: 12
#| fig-height: 10
#| out-width: 70%
#| fig-align: center
if (!interactive()) {
  slope_mainplot <- ggplot() +
    geom_sf(
      aes(fill = value),
      data = slope_mainland |> st_as_sf() |> setNames(c("value", "geometry")),
      linewidth = NA
    ) +
    theme_light() +
    scale_fill_gradientn(
      colours = terrain.colors(100),
      trans = modulus_trans(p = 0.8)
    ) +
    theme(
      axis.text = element_text(size = 19.5),
      legend.text = element_text(size = 19.5),
      legend.key.height = unit(3, "lines"),
      plot.title = element_text(face = "bold", size = 26, hjust = 0.5)
    ) +
    labs(fill = "", title = "Slope (°)")

  slope_pantelleria_plot <- ggplot() +
    geom_stars(data = slope_pantelleria |> st_warp(crs = 4326), na.action = na.omit, show.legend = FALSE) +
    coord_sf(crs = 4326) +
    scale_fill_gradientn(colours = terrain.colors(100), trans = modulus_trans(p = 0.8), limits = c(0, 80)) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", linewidth = 3),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  slope_lampedusa_plot <- ggplot() +
    geom_stars(data = slope_lampedusa |> st_warp(crs = 4326), na.action = na.omit, show.legend = FALSE) +
    coord_sf(crs = 4326) +
    scale_fill_gradientn(colours = terrain.colors(100), trans = scales::modulus_trans(p = 0.7), limits = c(0, 80)) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", linewidth = 3),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  slope_linosa_plot <- ggplot() +
    geom_stars(data = slope_linosa |> st_warp(crs = 4326), na.action = na.omit, show.legend = FALSE) +
    coord_sf(crs = 4326) +
    scale_fill_gradientn(colours = terrain.colors(100), trans = scales::modulus_trans(p = 0.7), limits = c(0, 80)) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", linewidth = 2),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.ticks.length = unit(0, "pt"),
      plot.margin = margin(0, 0, 0, 0),
      panel.grid = element_blank()
    )

  ggplot() +
    coord_equal(xlim = c(0, 24), ylim = c(0, 20), expand = FALSE) +
    annotation_custom(
      ggplotGrob(slope_mainplot),
      xmin = 0, xmax = 24, ymin = 0, ymax = 20
    ) +
    annotation_custom(
      ggplotGrob(slope_pantelleria_plot),
      xmin = 2.5, xmax = 5.5, ymin = 3.15, ymax = 6.15
    ) +
    annotation_custom(
      ggplotGrob(slope_lampedusa_plot),
      xmin = 6.25, xmax = 6.25 + 3 * diff(xrange_lampedusa) / diff(xrange_pantelleria),
      ymin = 3.8, ymax = 3.8 + 3 * diff(yrange_lampedusa) / diff(yrange_pantelleria)
    ) +
    annotation_custom(
      ggplotGrob(slope_linosa_plot),
      xmin = 9.5, xmax = 9.5 + 3 * diff(xrange_linosa) / diff(xrange_pantelleria),
      ymin = 4.2, ymax = 4.2 + 3 * diff(yrange_linosa) / diff(yrange_pantelleria)
    ) +
    theme(panel.background = element_rect(fill = "white"))
}
```

```{r}
#| include: false
rm(slope_mainland, slope_pantelleria, slope_linosa, slope_lampedusa)
if (!interactive()) {
  rm(slope_mainplot, slope_pantelleria_plot, slope_linosa_plot, slope_lampedusa_plot)
}
```

### Figure 8

The NDVI data can be loaded as follows

```{r}
NDVI_raw <- qcache(
  {
    tmp_dir <- tempdir()
    unzip(here("data", "NDVI.zip"), exdir = tmp_dir)
    files <- list.files(
      paste0(tmp_dir, "/NDVI"), 
      pattern = "\\.nc$",
      full.names = TRUE
    )
    # Currently, the structure returned by read_stars is an array with
    # dimension 1253 x 1116 and 36 attributes (1 for each NDVI in a 10 days
    # interval). We need to convert it to a 1253 x 1116 x 36 array with 1
    # attribute. See below (NDVI_tidy).
    out <- read_stars(files, quiet = TRUE, proxy = FALSE)
    unlink(paste0(tmp_dir, "/NDVI"), recursive = TRUE)
    out
  }, 
  name = "NDVI_raw", 
  cache_dir = here("qcache")
)
```

```{r}
#| include: false
if (exists("files")) {
  rm(files)
}
if (exists("out")) {
  rm(out)
}
```

As mentioned in the code chunk, the `NDVI_raw` object needs a bit of preprocessing to convert it into a usable format

```{r}
# The online docs say that the NDVI measurements are shared approximately
# every 10 days
day_jan <- c(
  as.Date("2023-01-01"), as.Date("2023-01-11"), as.Date("2023-01-21")
)

# The following code is taken from the first vignette of stars package.
NDVI_tidy <- qcache(
  {
    merge(NDVI_raw) |>
      setNames("NDVI") |>
      st_set_dimensions(
        3,
        values = c(
          day_jan,
          day_jan + months(1),
          day_jan + months(2),
          day_jan + months(3),
          day_jan + months(4),
          day_jan + months(5),
          day_jan + months(6),
          day_jan + months(7),
          day_jan + months(8),
          day_jan + months(9),
          day_jan + months(10),
          day_jan + months(11)
        ),
        names = "time"
      ) |>
      st_warp(crs = 3003, cellsize = c(500, 500))
  },
  name = "NDVI_tidy",
  cache_dir = here("qcache")
)
rm(day_jan)
invisible(gc())
```

We can temporally aggregate the NDVI values at the monthly level 

```{r}
NDVI_tidy_agg_1month <- qcache(
  {
    aggregate(NDVI_tidy, by = "months", FUN = mean)[mainland]
  },
  name = "NDVI_tidy_agg_1month",
  cache_dir = here("qcache")
)
```

and show them

```{r}
#| out-width: 70%
#| fig-align: center
#| fig-width: 12
#| fig-height: 10
if (!interactive()) {
  ggplot() + 
  geom_stars(data = NDVI_tidy_agg_1month, downsample = c(1, 1, 0)) + 
  facet_wrap(~time) + 
  scale_fill_gradient2(
    low = "#8d5e0b", 
    mid = "#e6e91a", 
    high = "#045b00", 
    midpoint = 0.5, 
    limits = c(-0.08, 0.92), 
    na.value = "lightblue"
  ) + 
  theme_light() + 
  theme(
    axis.text = element_blank(), 
    axis.ticks = element_blank(), 
    axis.title = element_blank(), 
    panel.grid = element_blank(), 
    panel.background = element_rect(fill = "lightblue"), 
    strip.text = element_text(face = "bold", size = 13), 
    legend.title = element_text(size = 13), 
    legend.text = element_text(size = 10)
  )
}
```

```{r}
#| include: false
rm(NDVI_tidy_agg_1month)
invisible(gc())
```

### Figure 9

The following code computes the average NDVI for each land use type

```{r}
NDVI_and_landuse <- qcache(
  {
    st_warp(
      NDVI_tidy,
      st_as_stars(st_bbox(NDVI_tidy), dx = 1500, dy = 1500)
    ) |>
      aggregate(
        by = land_use_tidy |> group_by(Code_18) |> summarise(),
        FUN = mean,
        na.rm = TRUE
      )
  },
  name = "NDVI_and_landuse",
  cache_dir = here("qcache")
)
```

and we can plot it as follows

```{r}
#| out-width: 70%
#| fig-align: center
#| fig-width: 8
#| fig-height: 5
if (!interactive()) {
  NDVI_and_landuse |> 
  st_as_sf() |> 
  mutate(idx = c("Artificial surfaces", "Agricultural areas", "Forests", "Water bodies")) |> 
    st_drop_geometry() |> 
  pivot_longer(!idx, names_to = "date", names_transform = list(
    date = as.Date
  )) |> 
  ggplot() + 
  geom_line(aes(x = date, y = value, col = idx, linetype = idx), linewidth = 1.3) + 
  theme_light() + 
  labs(x = "", y = "Average NDVI", linetype = "", col = "")
}
```

```{r}
#| include: false
rm(NDVI_and_landuse)
```

### Figure 10

First, we need to define a few auxiliary functions: 

```{r}
normalize <- function(x, max = 1) {
  x <- as.numeric(x)
  (x - min(x)) / (max(x) - min(x)) * max
}

# The following function is used to create the space-time representation
# of the environmental variables. See below. 
tf = function(x, y, w = .75, h = .33) {
  x2 = x * w + y * (1 - w)
  y2 = y * h
  x2[length(x2) + 1] = x2[1]
  y2[length(y2) + 1] = y2[1]
  list(x = x2, y = y2)
}
```

Next we load the environmental variables downloaded from ERA5

```{r}
env_var <- qcache(
  {
    tmp_dir <- tempdir()
    unzip(here("data", "environmental-variables.zip"), exdir = tmp_dir)
    nc_files <- list.files(
      paste0(tmp_dir, "/environmental-variables"),
      pattern = "\\.nc$",
      full.names = TRUE
    )
    img_combined <- lapply(
      nc_files,
      function(x, var) {
        img <- read_ncdf(x, var = var)
        if (grepl("october.nc", x, fixed = TRUE)) {
          img <- img[, , , 2, , drop = TRUE]
        }
        img
      },
      var = c("u10", "v10", "d2m", "t2m", "skt", "stl1", "stl2", "stl3", "stl4", "sp", "tp")
    ) |>
      do.call(c, args = _)
    unlink(nc_files); rm(nc_files); invisible(gc())
    st_crs(img_combined) <- "OGC:CRS84"
    st_warp(img_combined, crs = 3003)
  },
  name = "env_var",
  cache_dir = here("qcache")
)
env_var <- env_var[mainland]; invisible(gc) # Subset mainland
env_var <- aggregate(env_var, max, by = "1 day"); invisible(gc) # Take daily maximum
```

```{r}
#| include: false
if (exists("img_combined")) {
  rm(img_combined); invisible(gc())
}
```

Now we can replicate the space-time representation of the environmental variables. We start from Surface Pressure

```{r}
# Subset the surface pressure data and build the palette
sp_2months <- aggregate(
  env_var["sp", ], 
  mean, 
  by = "2 months", 
  na.rm = TRUE
)
sp_palette <- col_numeric(
  viridis::turbo(15), 
  domain = sp_2months$sp |> as.vector() |> range(na.rm = TRUE)
)
```

```{r}
#| out-width: 70%
#| fig-align: center
#| fig-width: 10.5
#| fig-height: 7.5
if (!interactive()) {
  grid.newpage()
  vp1 <- viewport(
    x = unit(0.35, "npc"),
    y = unit(0.35, "npc"),
    width = unit(0.8, "npc"),
    height = unit(0.8, "npc")
  )
  vp2 <- viewport(
    x = unit(0.9, "npc"),
    y = unit(0.35, "npc"),
    width = unit(0.25, "npc"),
    height = unit(0.6, "npc")
  )
  pushViewport(vp1)
  w <- 0.74
  h <- 0.175

  for (time_period in 1:6) {
    (sp_2months[, time_period, drop = TRUE]) |>
      st_as_sf() -> sp_2months_sf
    poly_cols <- sp_palette(sp_2months_sf$sp)
    poly_coords <- sp_2months_sf |>
      st_geometry() |>
      st_coordinates()
    poly_coords[, 1] <- normalize(poly_coords[, 1])
    poly_coords[, 2] <- normalize(poly_coords[, 2])
    xy_trans <- tf(poly_coords[, 1], poly_coords[, 2], w = w, h = h)
    for (i in unique(poly_coords[, 4])) {
      idx <- which(poly_coords[, 4] == i)
      grid.polygon(
        x = xy_trans$x[idx] + 0.075,
        y = xy_trans$y[idx] + 0.1 + (time_period - 1) * 0.9 / 12,
        gp = gpar(fill = poly_cols[i], col = NA, alpha = 1)
      )
    }

    sicily <- sp_2months_sf |>
      st_union() |>
      st_geometry()
    sicily_coords <- sicily |> st_coordinates()
    sicily_coords[, 1] <- normalize(sicily_coords[, 1])
    sicily_coords[, 2] <- normalize(sicily_coords[, 2])
    xy_trans <- tf(sicily_coords[, 1], sicily_coords[, 2], w = w, h = h)
    grid.polygon(
      x = xy_trans$x + 0.075,
      y = xy_trans$y + 0.1 + (time_period - 1) * 0.9 / 12,
      gp = gpar(fill = NA, col = "black", lwd = 2)
    )
  }
  grid.text(
    "Jan-Feb",
    x = unit(0.15, "npc"),
    y = unit(0.19, "npc"),
    gp = gpar(fontsize = 13, fontface = "bold")
  )
  grid.text(
    "Nov-Dec",
    x = unit(0.15, "npc"),
    y = unit(0.59, "npc"),
    gp = gpar(fontsize = 13, fontface = "bold")
  )
  grid.text(
    "Surface Pressure (Pa)",
    x = unit(0.65, "npc"),
    y = unit(0.7, "npc"),
    gp = gpar(fontsize = 20, fontface = "bold")
  )
  grid.segments(
    x0 = unit(0.15, "npc"),
    x1 = unit(0.15, "npc"),
    y0 = unit(0.21, "npc"),
    y1 = unit(0.565, "npc"),
    gp = gpar(lwd = 2),
    arrow = arrow()
  )
  popViewport()
  pushViewport(vp2)
  labels <- seq(88099, 102800, length.out = 5) |> pretty()
  grid.points(
    x = unit(rep(0.3, 5), "npc"),
    y = unit(seq(0.2, 0.6, length.out = 5), "npc"),
    pch = 21,
    size = unit(1.5, "char"),
    gp = gpar(fill = sp_palette(seq(89000, 102000, length.out = 5)))
  )
  grid.text(
    label = labels,
    x = unit(rep(0.55, 5), "npc"),
    y = unit(seq(0.2, 0.6, length.out = 5), "npc"),
    gp = gpar(fontsize = 15, fontface = "bold")
  )
}
```

and then focus on Skin Temperature

```{r}
stl2_2months <- aggregate(
  env_var["stl2", ],
  mean,
  by = "2 months",
  na.rm = TRUE
)
stl2_2months$stl2 <- stl2_2months$stl2 - 273.15

stl2_palette <- col_numeric(
  viridis::turbo(15),
  domain = stl2_2months$stl2 |> as.vector() |> range(na.rm = TRUE)
)
```

```{r}
#| out-width: 70%
#| fig-align: center
#| fig-width: 10.5
#| fig-height: 7.5
if (!interactive()) {
  grid.newpage()
  vp1 <- viewport(
    x = unit(0.35, "npc"),
    y = unit(0.35, "npc"),
    width = unit(0.8, "npc"),
    height = unit(0.8, "npc")
  )
  vp2 <- viewport(
    x = unit(0.9, "npc"),
    y = unit(0.35, "npc"),
    width = unit(0.25, "npc"),
    height = unit(0.6, "npc")
  )
  pushViewport(vp1)
  w <- 0.74
  h <- 0.175
  for (time_period in 1:6) {
    (stl2_2months[, time_period, drop = TRUE]) |>
      st_as_sf() -> stl2_2months_sf
    poly_cols <- stl2_palette(stl2_2months_sf$stl2)
    poly_coords <- stl2_2months_sf |>
      st_geometry() |>
      st_coordinates()
    poly_coords[, 1] <- normalize(poly_coords[, 1])
    poly_coords[, 2] <- normalize(poly_coords[, 2])
    xy_trans <- tf(poly_coords[, 1], poly_coords[, 2], w = w, h = h)
    for (i in unique(poly_coords[, 4])) {
      idx <- which(poly_coords[, 4] == i)
      grid.polygon(
        x = xy_trans$x[idx] + 0.075,
        y = xy_trans$y[idx] + 0.1 + (time_period - 1) * 0.9 / 12,
        gp = gpar(fill = poly_cols[i], col = NA, alpha = 1)
      )
    }

    sicily <- stl2_2months_sf |>
      st_union() |>
      st_geometry()
    sicily_coords <- sicily |> st_coordinates()
    sicily_coords[, 1] <- normalize(sicily_coords[, 1])
    sicily_coords[, 2] <- normalize(sicily_coords[, 2])
    xy_trans <- tf(sicily_coords[, 1], sicily_coords[, 2], w = w, h = h)
    grid.polygon(
      x = xy_trans$x + 0.075,
      y = xy_trans$y + 0.1 + (time_period - 1) * 0.9 / 12,
      gp = gpar(fill = NA, col = "black", lwd = 2)
    )
  }
  grid.text(
    "Jan-Feb",
    x = unit(0.15, "npc"),
    y = unit(0.19, "npc"),
    gp = gpar(fontsize = 13, fontface = "bold")
  )
  grid.text(
    "Nov-Dec",
    x = unit(0.15, "npc"),
    y = unit(0.59, "npc"),
    gp = gpar(fontsize = 13, fontface = "bold")
  )
  grid.text(
    "Skin Temperature (Celsius)",
    x = unit(0.65, "npc"),
    y = unit(0.7, "npc"),
    gp = gpar(fontsize = 20, fontface = "bold")
  )
  grid.segments(
    x0 = unit(0.15, "npc"),
    x1 = unit(0.15, "npc"),
    y0 = unit(0.21, "npc"),
    y1 = unit(0.565, "npc"),
    gp = gpar(lwd = 2),
    arrow = arrow()
  )
  popViewport()
  pushViewport(vp2)
  labels <- seq(5, 35, length.out = 5) |> pretty()
  grid.points(
    x = unit(rep(0.3, 7), "npc"),
    y = unit(seq(0.1, 0.6, length.out = 7), "npc"),
    pch = 21,
    size = unit(1.5, "char"),
    gp = gpar(fill = stl2_palette(seq(6.5, 33, length.out = 7)))
  )
  grid.text(
    label = labels,
    x = unit(rep(0.5, 7), "npc"),
    y = unit(seq(0.1, 0.6, length.out = 7), "npc"),
    gp = gpar(fontsize = 18, fontface = "bold")
  )
}
```

```{r}
#| include: false
rm(env_var, sp_2months, sp_palette, stl2_2months, stl2_palette)
if (!interactive()) {
  rm(h, i, idx, labels, poly_cols, poly_coords, sicily, sicily_coords, sp_2months_sf, stl2_2months_sf, time_period, vp1, vp2, w, xy_trans)
}
```

## Section 4

### Figure 11

Now we replicate the plots regarding the temporal distribution of some environmental variables. First we need to reload the data (since we modified it to create the previous plot) and adjust its format slightly: 

```{r}
cov_time <- qcache(
  {
    tmp_dir <- tempdir()
    unzip(here("data", "environmental-variables.zip"), exdir = tmp_dir)
    nc_files <- list.files(
      paste0(tmp_dir, "/environmental-variables"),
      pattern = "\\.nc$",
      full.names = TRUE
    )

    nome_file <- c(
      "january.nc", "february.nc", "march.nc", "april.nc",
      "may.nc", "june.nc", "july.nc",
      "august.nc", "september.nc", "october.nc", "november.nc",
      "december.nc"
    )

    lista <- list()
    for (i in nc_files) {
      k <- which(nome_file == basename(i))
      suppressMessages({
        prova <- read_ncdf(i)
      })
      st_crs(prova) <- 4326
      prova <- st_warp(prova, crs = 3003)
      prova <- prova[mainland]

      if (basename(i) == "october.nc") {
        prova2 <- aggregate(prova[, , , 2, , drop = TRUE], max, by = "1 day")[, -1] |>
          st_apply(c("time"), function(z) max(z, na.rm = TRUE))
      } else {
        prova2 <- aggregate(prova[, , , ], max, by = "1 day") |>
          st_apply(c("time"), function(z) max(z, na.rm = TRUE))
      }

      prova2 <- as.data.frame(prova2)
      prova2$month <- rep(k, nrow(prova2))
      prova2$day <- 1:nrow(prova2)
      lista[[k]] <- prova2
      rm(prova, prova2)
      invisible(gc())
    }
    rm(nome_file, i, k)
    unlink(nc_files); rm(nc_files); invisible(gc())

    do.call(rbind, lista)
  },
  name = "cov_time",
  cache_dir = here("qcache")
)
```

```{r}
if (exists("lista")) {
  rm(lista)
}
```

We need to convert Kelvin to Celsius

```{r}
cov_time$d2m <- cov_time$d2m - 273.15
cov_time$t2m <- cov_time$t2m - 273.15
cov_time$skt <- cov_time$skt - 273.15
cov_time$stl1 <- cov_time$stl1 - 273.15
cov_time$stl2 <- cov_time$stl2 - 273.15
cov_time$stl3 <- cov_time$stl3 - 273.15
cov_time$stl4 <- cov_time$stl4 - 273.15
```

and now we are ready to plot

```{r}
#| out-width: 70%
#| fig-align: center
#| fig-width: 12
#| fig-height: 8
if (!interactive()) {
  par(mfrow = c(2, 2))
  plot(
    cov_time$time, cov_time$u10, type = "l", col = 5, 
    xlab = "", ylab = "m/s", main = "Wind Speed", lwd = 2
  )
  lines(cov_time$time, cov_time$v10, col = 6, lwd = 2)
  legend("top", legend = c("u10", "v10"), col = c(5, 6), lty = 1, cex = 0.8, lwd = 2)
  
  plot(
    cov_time$time, cov_time$d2m, type = "l", col = 4, 
    xlab = "", ylab = "Celsius", main = "Temperatures", lwd = 2, 
    ylim = c(2, 60)
  )
  lines(cov_time$time, cov_time$t2m, col = 5, lwd = 2)
  lines(cov_time$time, cov_time$skt, col = 6, lwd = 2)
  lines(cov_time$time, cov_time$stl1, col = 7, lwd = 2)
  lines(cov_time$time, cov_time$stl2, col = 8, lwd = 2)
  lines(cov_time$time, cov_time$stl3, col = 9, lwd = 2)
  lines(cov_time$time, cov_time$stl4, col = 10, lwd = 2)
  legend("topleft", legend=c("d2m", "t2m", "skt", "stl1", "stl2", "stl3", "stl4"),
       col=c(4:10), lty=1, cex=0.8, lwd = 2)
  
  plot(
    cov_time$time, cov_time$tp, type = "l", col = 4, 
    xlab = "", ylab = "m", main = "Precipitations", lwd = 2 
  )
  
  plot(
    cov_time$time, cov_time$sp, type = "l", col = 4, 
    xlab = "", ylab = "Pa", main = "Surface Pressure", lwd = 2 
  )
}
```

### Figure 12

Next we focus on the pairs plot

```{r pairs_temperature}
#| out-width: 70%
#| fig-align: center
#| fig-width: 12
#| fig-height: 12
panel.hist <- function(x, ...)
{
  usr <- par("usr")
  par(usr = c(usr[1:2], 0, 1.5) )
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col = "grey", ...)
}

panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...)
{
  par(usr = c(0, 1, 0, 1))
  r <- abs(cor(x, y))
  txt <- format(c(r, 0.123456789), digits = digits)[1]
  txt <- paste0(prefix, txt)
  if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
  text(0.5, 0.5, txt, cex = cex.cor * r)
}
if (!interactive()) {
  pairs(
    cov_time[,c(2:12)], upper.panel = panel.cor, diag.panel = panel.hist,
    lower.panel = panel.smooth, pch = "."
  )
}
```

```{r}
#| include: false
rm(cov_time, panel.hist, panel.cor)
```
